Description: support systemd socket activation
 Unlike inetd socket activation, with systemd socket activation the 
 supervisor passes the listened-on socket to the child process and lets 
 the child process handle the accept().  This lets us do delayed start 
 of the sshd daemon without becoming incompatible with config options 
 like ClientAliveCountMax.
Author: Steve Langasek <steve.langasek@ubuntu.com>

Index: openssh/sshd.c
===================================================================
--- openssh.orig/sshd.c
+++ openssh/sshd.c
@@ -141,10 +141,16 @@
 #endif /* LIBWRAP */
 
 /* Re-exec fds */
-#define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
-#define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2)
-#define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3)
-#define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4)
+#ifdef HAVE_SYSTEMD
+#define SYSTEMD_OFFSET sd_listen_fds(0)
+#else
+#define SYSTEMD_OFFSET 0
+#endif
+
+#define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1 + SYSTEMD_OFFSET)
+#define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2 + SYSTEMD_OFFSET)
+#define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3 + SYSTEMD_OFFSET)
+#define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4 + SYSTEMD_OFFSET)
 
 extern char *__progname;
 
@@ -1033,6 +1039,51 @@
 	debug("inetd sockets after dupping: %d, %d", *sock_in, *sock_out);
 }
 
+#ifdef HAVE_SYSTEMD
+/*
+ * Configure our socket fds that were passed from systemd
+ */
+static void
+setup_systemd_socket(int listen_sock)
+{
+	int ret;
+	struct sockaddr addr;
+	socklen_t len;
+	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
+
+	if (getsockname(listen_sock, &addr, &len) != 0)
+		return;
+
+	if (addr.sa_family != AF_INET && addr.sa_family != AF_INET6)
+		return;
+	if (num_listen_socks >= MAX_LISTEN_SOCKS)
+		fatal("Too many listen sockets. "
+		    "Enlarge MAX_LISTEN_SOCKS");
+	if ((ret = getnameinfo(&addr, len, ntop, sizeof(ntop),
+	                       strport, sizeof(strport),
+	                       NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
+		error("getnameinfo failed: %.100s",
+		    ssh_gai_strerror(ret));
+		return;
+	}
+	if (set_nonblock(listen_sock) == -1) {
+		close(listen_sock);
+		return;
+	}
+	/* Socket options */
+	set_reuseaddr(listen_sock);
+
+	/* Only communicate in IPv6 over AF_INET6 sockets. */
+	if (addr.sa_family == AF_INET6)
+		sock_set_v6only(listen_sock);
+
+	listen_socks[num_listen_socks] = listen_sock;
+	num_listen_socks++;
+
+	logit("Server listening on %s port %s.", ntop, strport);
+}
+#endif
+
 /*
  * Listen for TCP connections
  */
@@ -1561,6 +1612,9 @@
 	int keytype;
 	Authctxt *authctxt;
 	struct connection_info *connection_info = NULL;
+#ifdef HAVE_SYSTEMD
+	int systemd_socket_count;
+#endif
 
 #ifdef HAVE_SECUREWARE
 	(void)set_auth_parameters(ac, av);
@@ -2065,7 +2119,16 @@
 		server_accept_inetd(&sock_in, &sock_out);
 	} else {
 		platform_pre_listen();
-		server_listen();
+#ifdef HAVE_SYSTEMD
+		systemd_socket_count = sd_listen_fds(0);
+		if (systemd_socket_count > 0)
+		{
+			int i;
+			for (i = 0; i < systemd_socket_count; i++)
+				setup_systemd_socket(SD_LISTEN_FDS_START + i);
+		} else
+#endif
+			server_listen();
 
 		ssh_signal(SIGHUP, sighup_handler);
 		ssh_signal(SIGCHLD, main_sigchld_handler);
